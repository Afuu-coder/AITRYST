import { db, storage } from './firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { 
  collection, 
  addDoc, 
  getDocs, 
  getDoc, 
  doc, 
  updateDoc, 
  deleteDoc,
  query,
  where,
  orderBy,
  limit
} from 'firebase/firestore';
import { StorageReference } from 'firebase/storage';

// We'll use API routes for Vertex AI functionality instead of direct imports
// This avoids the "net" module issue in the browser

/**
 * Generate AI content using our API route
 */
export const generateAIContent = async (prompt: string, language: 'en' | 'hi' = 'en') => {
  try {
    console.log('Generating AI content for prompt:', prompt, 'in language:', language);
    
    // Call our API route instead of using Vertex AI directly
    const response = await fetch('/api/vertex-ai', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ prompt, language }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    
    // Ensure we return a properly structured response
    return {
      headline: result.headline || 'AI-Generated Content',
      description: result.description || 'This content was generated by AI.',
      socialPost: result.socialPost || 'Check out our handcrafted product!',
      whatsappMessage: result.whatsappMessage || 'Check out our latest handcrafted product!',
      emailSubject: result.emailSubject || 'Special Offer for You',
      emailBody: result.emailBody || 'We have a special offer for you!',
      offer: result.offer || 'Special 25% OFF on all products'
    };
  } catch (error) {
    console.error('Error generating AI content:', error);
    // Return placeholder content as fallback
    if (language === 'hi') {
      return {
        headline: 'एआई-जनित सामग्री',
        description: 'यह सामग्री हिंदी में एआई द्वारा उत्पन्न की गई है।',
        socialPost: 'हमारे हस्तशिल्प उत्पाद के बारे में! 🏺 #हस्तशिल्प #भारत',
        whatsappMessage: 'हमारे नवीनतम हस्तशिल्प उत्पाद की जाँच करें!',
        emailSubject: 'आपके लिए विशेष प्रस्ताव',
        emailBody: 'हमारे पास आपके लिए एक विशेष प्रस्ताव है!',
        offer: 'सभी उत्पादों पर विशेष 25% छूट'
      };
    } else {
      return {
        headline: 'AI-Generated Content',
        description: 'This content was generated by AI in English.',
        socialPost: 'Check out our handcrafted product! 🏺 #Craftsmanship #India',
        whatsappMessage: 'Check out our latest handcrafted product!',
        emailSubject: 'Special Offer for You',
        emailBody: 'We have a special offer for you!',
        offer: 'Special 25% OFF on all products'
      };
    }
  }
};

/**
 * Transcribe audio using our API route
 */
export const transcribeAudio = async (audioBlob: Blob) => {
  try {
    console.log('Transcribing audio...');
    
    // Create FormData to send the audio file
    const formData = new FormData();
    formData.append('audio', audioBlob);
    
    // Call our API route for transcription
    const response = await fetch('/api/transcribe', {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    return result.transcription || "This is a placeholder transcription of the audio content.";
  } catch (error) {
    console.error('Error transcribing audio:', error);
    throw error;
  }
};

/**
 * Enhance image using our API route
 */
export const enhanceImage = async (
  imageUrl: string, 
  enhancementOptions?: any
) => {
  try {
    console.log('Enhancing image:', imageUrl, 'with options:', enhancementOptions);
    
    // Call our API route for image enhancement
    const response = await fetch('/api/enhance-image', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ imageUrl, enhancementOptions }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('API error response:', errorText);
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    console.log('Enhancement result:', result);

    return result.enhancedImageUrl || imageUrl;
  } catch (error) {
    console.error('Error enhancing image:', error);
    // Re-throw the error so it can be handled properly by the frontend
    throw error;
  }
};

// Types
export interface Product {
  id?: string;
  name: string;
  description: string;
  price: number;
  artisanId: string;
  imageUrl: string;
  category: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface Artisan {
  id?: string;
  name: string;
  email: string;
  phone: string;
  address: string;
  bio: string;
  profileImageUrl: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface Campaign {
  id?: string;
  artisanId: string;
  title: string;
  description: string;
  festival: string;
  startDate: Date;
  endDate: Date;
  products: string[]; // Product IDs
  createdAt: Date;
  updatedAt: Date;
}

export interface PricingData {
  materialCost: number;
  laborCost: number;
  overhead: number;
  suggestedPrice: number;
  platformPrices: {
    local: number;
    online: number;
    premium: number;
    wholesale: number;
  };
  recommendations?: {
    bestSellingPrice: number;
    competitorAnalysis: string;
    seasonalAdjustment: string;
    bulkDiscount: string;
  };
}

// Product Management
export const createProduct = async (product: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>) => {
  try {
    if (!db) {
      console.log('🔄 Firebase not available, using mock product creation');
      return { 
        id: 'mock-' + Date.now(), 
        ...product, 
        createdAt: new Date(), 
        updatedAt: new Date() 
      };
    }
    
    const productWithTimestamps = {
      ...product,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const docRef = await addDoc(collection(db, 'products'), productWithTimestamps);
    return { id: docRef.id, ...productWithTimestamps };
  } catch (error) {
    console.error('Error creating product:', error);
    throw error;
  }
};

export const getProductsByArtisan = async (artisanId: string) => {
  try {
    if (!db) {
      console.log('🔄 Firebase not available, returning mock products');
      return [
        {
          id: 'mock-1',
          name: 'Sample Handcrafted Pottery',
          description: 'Beautiful handcrafted pottery with traditional patterns',
          price: 1500,
          artisanId: artisanId,
          imageUrl: '/enhanced-pottery-vase-with-better-lighting-and-bac.jpg',
          category: 'pottery',
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];
    }
    
    const q = query(
      collection(db, 'products'),
      where('artisanId', '==', artisanId),
      orderBy('createdAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    } as Product));
  } catch (error) {
    console.error('Error fetching products:', error);
    throw error;
  }
};

export const getProduct = async (productId: string) => {
  try {
    const docRef = doc(db, 'products', productId);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as Product;
    } else {
      throw new Error('Product not found');
    }
  } catch (error) {
    console.error('Error fetching product:', error);
    throw error;
  }
};

export const updateProduct = async (productId: string, product: Partial<Product>) => {
  try {
    const productWithTimestamps = {
      ...product,
      updatedAt: new Date()
    };
    
    const docRef = doc(db, 'products', productId);
    await updateDoc(docRef, productWithTimestamps);
    
    return { id: productId, ...productWithTimestamps };
  } catch (error) {
    console.error('Error updating product:', error);
    throw error;
  }
};

export const deleteProduct = async (productId: string) => {
  try {
    await deleteDoc(doc(db, 'products', productId));
    return true;
  } catch (error) {
    console.error('Error deleting product:', error);
    throw error;
  }
};

// Artisan Management
export const createArtisan = async (artisan: Omit<Artisan, 'id' | 'createdAt' | 'updatedAt'>) => {
  try {
    const artisanWithTimestamps = {
      ...artisan,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const docRef = await addDoc(collection(db, 'artisans'), artisanWithTimestamps);
    return { id: docRef.id, ...artisanWithTimestamps };
  } catch (error) {
    console.error('Error creating artisan:', error);
    throw error;
  }
};

export const getArtisan = async (artisanId: string) => {
  try {
    const docRef = doc(db, 'artisans', artisanId);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as Artisan;
    } else {
      throw new Error('Artisan not found');
    }
  } catch (error) {
    console.error('Error fetching artisan:', error);
    throw error;
  }
};

export const updateArtisan = async (artisanId: string, artisan: Partial<Artisan>) => {
  try {
    const artisanWithTimestamps = {
      ...artisan,
      updatedAt: new Date()
    };
    
    const docRef = doc(db, 'artisans', artisanId);
    await updateDoc(docRef, artisanWithTimestamps);
    
    return { id: artisanId, ...artisanWithTimestamps };
  } catch (error) {
    console.error('Error updating artisan:', error);
    throw error;
  }
};

// Campaign Management
export const createCampaign = async (campaign: Omit<Campaign, 'id' | 'createdAt' | 'updatedAt'>) => {
  try {
    const campaignWithTimestamps = {
      ...campaign,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const docRef = await addDoc(collection(db, 'campaigns'), campaignWithTimestamps);
    return { id: docRef.id, ...campaignWithTimestamps };
  } catch (error) {
    console.error('Error creating campaign:', error);
    throw error;
  }
};

export const getCampaignsByArtisan = async (artisanId: string) => {
  try {
    const q = query(
      collection(db, 'campaigns'),
      where('artisanId', '==', artisanId),
      orderBy('createdAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    } as Campaign));
  } catch (error) {
    console.error('Error fetching campaigns:', error);
    throw error;
  }
};

// Media Upload - Google Cloud Storage implementation
export const uploadImage = async (file: File, path: string) => {
  try {
    console.log('Uploading image to Google Cloud Storage:', file.name, 'at path:', path);
    
    // For now, we'll use local object URL since we need to set up Cloud Storage properly
    // In production, you would upload to Google Cloud Storage:
    /*
    const { Storage } = require('@google-cloud/storage');
    const storage = new Storage({
      projectId: process.env.GOOGLE_CLOUD_PROJECT_ID,
      keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS
    });
    
    const bucket = storage.bucket(process.env.GOOGLE_CLOUD_STORAGE_BUCKET);
    const fileUpload = bucket.file(path);
    
    const stream = fileUpload.createWriteStream({
      metadata: {
        contentType: file.type,
      },
    });
    
    return new Promise((resolve, reject) => {
      stream.on('error', (err) => {
        console.error('Upload error:', err);
        reject(err);
      });
      
      stream.on('finish', async () => {
        try {
          await fileUpload.makePublic();
          const publicUrl = `https://storage.googleapis.com/${bucket.name}/${path}`;
          console.log('Image uploaded to Cloud Storage:', publicUrl);
          resolve(publicUrl);
        } catch (err) {
          console.error('Error making file public:', err);
          reject(err);
        }
      });
      
      stream.end(Buffer.from(await file.arrayBuffer()));
    });
    */
    
    // Temporary local implementation
    const objectUrl = URL.createObjectURL(file);
    console.log('Image URL created (local):', objectUrl);
    return objectUrl;
  } catch (error) {
    console.error('Error uploading image:', error);
    // Provide more detailed error information
    if (error instanceof Error) {
      throw new Error(`Upload failed: ${error.message}`);
    } else {
      throw new Error('Upload failed: Unknown error occurred');
    }
  }
};

export const calculatePricing = async (materialCost: number, hoursWorked: number, productType: string) => {
  try {
    // Call our API route for AI-powered pricing
    const response = await fetch('/api/calculate-pricing', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ materialCost, hoursWorked, productType }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const pricingData = await response.json();
    return pricingData as PricingData;
  } catch (error) {
    console.error('Error calculating pricing:', error);
    
    // Fallback to simple pricing algorithm
    const laborCost = hoursWorked * 150; // ₹150 per hour base rate
    const overheadCost = materialCost * 0.3; // 30% overhead
    const baseCost = materialCost + laborCost + overheadCost;
    
    // Product type multipliers
    const multipliers: Record<string, number> = {
      'pottery': 1.2,
      'textiles': 1.5,
      'jewelry': 2.0,
      'woodwork': 1.3,
      'metalwork': 1.4,
      'paintings': 1.8,
      'default': 1.2
    };
    
    const typeMultiplier = multipliers[productType] || multipliers['default'];
    const suggestedPrice = Math.round(baseCost * typeMultiplier);
    
    const pricingData: PricingData = {
      materialCost,
      laborCost,
      overhead: overheadCost,
      suggestedPrice,
      platformPrices: {
        local: suggestedPrice,
        online: Math.round(suggestedPrice * 1.2), // 20% markup for online
        premium: Math.round(suggestedPrice * 1.5), // 50% markup for premium markets
        wholesale: Math.round(suggestedPrice * 0.7) // 30% discount for wholesale
      }
    };
    
    return pricingData;
  }
};

// QR Code Generation using Google Cloud services
export const generateQRCode = async (productId: string) => {
  try {
    // Call our API route for QR code generation
    const response = await fetch('/api/generate-qr', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ productId }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    return result.qrCodeUrl;
  } catch (error) {
    console.error('Error generating QR code:', error);
    
    // Fallback to a placeholder QR code service
    return `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(productId)}`;
  }
};

// AI Services (Placeholder - to be implemented with Vertex AI)